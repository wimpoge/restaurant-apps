"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
<<<<<<< HEAD

var _helperPluginUtils = require("@babel/helper-plugin-utils");

var _helperRemapAsyncToGenerator = require("@babel/helper-remap-async-to-generator");

var _pluginSyntaxAsyncGenerators = require("@babel/plugin-syntax-async-generators");

var _core = require("@babel/core");

var _forAwait = require("./for-await");

var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const yieldStarVisitor = {
    Function(path) {
      path.skip();
    },

=======
var _helperPluginUtils = require("@babel/helper-plugin-utils");
var _helperRemapAsyncToGenerator = require("@babel/helper-remap-async-to-generator");
var _pluginSyntaxAsyncGenerators = require("@babel/plugin-syntax-async-generators");
var _core = require("@babel/core");
var _forAwait = require("./for-await");
var _helperEnvironmentVisitor = require("@babel/helper-environment-visitor");
var _default = (0, _helperPluginUtils.declare)(api => {
  api.assertVersion(7);
  const yieldStarVisitor = _core.traverse.visitors.merge([{
    ArrowFunctionExpression(path) {
      path.skip();
    },
>>>>>>> master
    YieldExpression({
      node
    }, state) {
      if (!node.delegate) return;
<<<<<<< HEAD
      const callee = state.addHelper("asyncGeneratorDelegate");
      node.argument = _core.types.callExpression(callee, [_core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]), state.addHelper("awaitAsyncGenerator")]);
    }

  };
  const forAwaitVisitor = {
    Function(path) {
      path.skip();
    },

=======
      const asyncIter = _core.types.callExpression(state.addHelper("asyncIterator"), [node.argument]);
      node.argument = _core.types.callExpression(state.addHelper("asyncGeneratorDelegate"), [asyncIter, state.addHelper("awaitAsyncGenerator")]);
    }
  }, _helperEnvironmentVisitor.default]);
  const forAwaitVisitor = _core.traverse.visitors.merge([{
    ArrowFunctionExpression(path) {
      path.skip();
    },
>>>>>>> master
    ForOfStatement(path, {
      file
    }) {
      const {
        node
      } = path;
      if (!node.await) return;
      const build = (0, _forAwait.default)(path, {
        getAsyncIterator: file.addHelper("asyncIterator")
      });
      const {
        declar,
        loop
      } = build;
      const block = loop.body;
<<<<<<< HEAD
=======

>>>>>>> master
      path.ensureBlock();

      if (declar) {
        block.body.push(declar);
<<<<<<< HEAD
      }

      block.body.push(...node.body.body);

      _core.types.inherits(loop, node);

      _core.types.inherits(loop.body, node.body);

=======
        if (path.node.body.body.length) {
          block.body.push(_core.types.blockStatement(path.node.body.body));
        }
      } else {
        block.body.push(...path.node.body.body);
      }
      _core.types.inherits(loop, node);
      _core.types.inherits(loop.body, node.body);
>>>>>>> master
      if (build.replaceParent) {
        path.parentPath.replaceWithMultiple(build.node);
      } else {
        path.replaceWithMultiple(build.node);
      }
    }
<<<<<<< HEAD

  };
=======
  }, _helperEnvironmentVisitor.default]);
>>>>>>> master
  const visitor = {
    Function(path, state) {
      if (!path.node.async) return;
      path.traverse(forAwaitVisitor, state);
      if (!path.node.generator) return;
      path.traverse(yieldStarVisitor, state);
<<<<<<< HEAD
=======

>>>>>>> master
      (0, _helperRemapAsyncToGenerator.default)(path, {
        wrapAsync: state.addHelper("wrapAsyncGenerator"),
        wrapAwait: state.addHelper("awaitAsyncGenerator")
      });
    }
<<<<<<< HEAD

=======
>>>>>>> master
  };
  return {
    name: "proposal-async-generator-functions",
    inherits: _pluginSyntaxAsyncGenerators.default,
    visitor: {
      Program(path, state) {
        path.traverse(visitor, state);
      }
<<<<<<< HEAD

    }
  };
});

exports.default = _default;
=======
    }
  };
});
exports.default = _default;

//# sourceMappingURL=index.js.map
>>>>>>> master
