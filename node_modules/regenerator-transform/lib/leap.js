"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
<<<<<<< HEAD

var _assert = _interopRequireDefault(require("assert"));

var _emit = require("./emit");

var _util = require("util");

var _util2 = require("./util");

=======
var _assert = _interopRequireDefault(require("assert"));
var _emit = require("./emit");
var _util = require("util");
var _util2 = require("./util");
>>>>>>> master
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
<<<<<<< HEAD
function Entry() {
  _assert["default"].ok(this instanceof Entry);
}

=======

function Entry() {
  _assert["default"].ok(this instanceof Entry);
}
>>>>>>> master
function FunctionEntry(returnLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(returnLoc);
  this.returnLoc = returnLoc;
}
<<<<<<< HEAD

(0, _util.inherits)(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;

=======
(0, _util.inherits)(FunctionEntry, Entry);
exports.FunctionEntry = FunctionEntry;
>>>>>>> master
function LoopEntry(breakLoc, continueLoc, label) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(breakLoc);
  t.assertLiteral(continueLoc);
<<<<<<< HEAD

=======
>>>>>>> master
  if (label) {
    t.assertIdentifier(label);
  } else {
    label = null;
  }
<<<<<<< HEAD

=======
>>>>>>> master
  this.breakLoc = breakLoc;
  this.continueLoc = continueLoc;
  this.label = label;
}
<<<<<<< HEAD

(0, _util.inherits)(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;

=======
(0, _util.inherits)(LoopEntry, Entry);
exports.LoopEntry = LoopEntry;
>>>>>>> master
function SwitchEntry(breakLoc) {
  Entry.call(this);
  (0, _util2.getTypes)().assertLiteral(breakLoc);
  this.breakLoc = breakLoc;
}
<<<<<<< HEAD

(0, _util.inherits)(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;

=======
(0, _util.inherits)(SwitchEntry, Entry);
exports.SwitchEntry = SwitchEntry;
>>>>>>> master
function TryEntry(firstLoc, catchEntry, finallyEntry) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
<<<<<<< HEAD

=======
>>>>>>> master
  if (catchEntry) {
    _assert["default"].ok(catchEntry instanceof CatchEntry);
  } else {
    catchEntry = null;
  }
<<<<<<< HEAD

=======
>>>>>>> master
  if (finallyEntry) {
    _assert["default"].ok(finallyEntry instanceof FinallyEntry);
  } else {
    finallyEntry = null;
<<<<<<< HEAD
  } // Have to have one or the other (or both).


  _assert["default"].ok(catchEntry || finallyEntry);

=======
  }

  // Have to have one or the other (or both).
  _assert["default"].ok(catchEntry || finallyEntry);
>>>>>>> master
  this.firstLoc = firstLoc;
  this.catchEntry = catchEntry;
  this.finallyEntry = finallyEntry;
}
<<<<<<< HEAD

(0, _util.inherits)(TryEntry, Entry);
exports.TryEntry = TryEntry;

=======
(0, _util.inherits)(TryEntry, Entry);
exports.TryEntry = TryEntry;
>>>>>>> master
function CatchEntry(firstLoc, paramId) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertIdentifier(paramId);
  this.firstLoc = firstLoc;
  this.paramId = paramId;
}
<<<<<<< HEAD

(0, _util.inherits)(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;

=======
(0, _util.inherits)(CatchEntry, Entry);
exports.CatchEntry = CatchEntry;
>>>>>>> master
function FinallyEntry(firstLoc, afterLoc) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(firstLoc);
  t.assertLiteral(afterLoc);
  this.firstLoc = firstLoc;
  this.afterLoc = afterLoc;
}
<<<<<<< HEAD

(0, _util.inherits)(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;

=======
(0, _util.inherits)(FinallyEntry, Entry);
exports.FinallyEntry = FinallyEntry;
>>>>>>> master
function LabeledEntry(breakLoc, label) {
  Entry.call(this);
  var t = (0, _util2.getTypes)();
  t.assertLiteral(breakLoc);
  t.assertIdentifier(label);
  this.breakLoc = breakLoc;
  this.label = label;
}
<<<<<<< HEAD

(0, _util.inherits)(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;

function LeapManager(emitter) {
  _assert["default"].ok(this instanceof LeapManager);

  _assert["default"].ok(emitter instanceof _emit.Emitter);

  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}

var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;

LMp.withEntry = function (entry, callback) {
  _assert["default"].ok(entry instanceof Entry);

  this.entryStack.push(entry);

=======
(0, _util.inherits)(LabeledEntry, Entry);
exports.LabeledEntry = LabeledEntry;
function LeapManager(emitter) {
  _assert["default"].ok(this instanceof LeapManager);
  _assert["default"].ok(emitter instanceof _emit.Emitter);
  this.emitter = emitter;
  this.entryStack = [new FunctionEntry(emitter.finalLoc)];
}
var LMp = LeapManager.prototype;
exports.LeapManager = LeapManager;
LMp.withEntry = function (entry, callback) {
  _assert["default"].ok(entry instanceof Entry);
  this.entryStack.push(entry);
>>>>>>> master
  try {
    callback.call(this.emitter);
  } finally {
    var popped = this.entryStack.pop();
<<<<<<< HEAD

    _assert["default"].strictEqual(popped, entry);
  }
};

=======
    _assert["default"].strictEqual(popped, entry);
  }
};
>>>>>>> master
LMp._findLeapLocation = function (property, label) {
  for (var i = this.entryStack.length - 1; i >= 0; --i) {
    var entry = this.entryStack[i];
    var loc = entry[property];
<<<<<<< HEAD

=======
>>>>>>> master
    if (loc) {
      if (label) {
        if (entry.label && entry.label.name === label.name) {
          return loc;
        }
<<<<<<< HEAD
      } else if (entry instanceof LabeledEntry) {// Ignore LabeledEntry entries unless we are actually breaking to
=======
      } else if (entry instanceof LabeledEntry) {
        // Ignore LabeledEntry entries unless we are actually breaking to
>>>>>>> master
        // a label.
      } else {
        return loc;
      }
    }
  }
<<<<<<< HEAD

  return null;
};

LMp.getBreakLoc = function (label) {
  return this._findLeapLocation("breakLoc", label);
};

=======
  return null;
};
LMp.getBreakLoc = function (label) {
  return this._findLeapLocation("breakLoc", label);
};
>>>>>>> master
LMp.getContinueLoc = function (label) {
  return this._findLeapLocation("continueLoc", label);
};